use alloc::vec::Vec;

use emfat_rust::{emfat_entry, emfat_t};

use usbd_scsi::{BlockDevice, BlockDeviceError};

pub struct EMfatStorage {
    ctx: emfat_t,
    fstable: Vec<emfat_entry>,
}

struct StaticData {
    data: &'static str,
}

// terminate strings with '\0' for strlen() compatible

static README: &str = "# СКТБ \"ЭЛПА\": Автономный регистратор давления\n\
\n\
Этот виртуальный диск предоставляет доступ к содержимому внутреннего накопителя устройства.\n\
\n\
- Для расшифровки содержимого используйте программу %TODO%.\n\
- Коэффициенты полиномов для рассчета находятся в файле %TODO%\n\
- Для управление функционалом устройства используйте программу KalibratorGUI\n";

static README_INFO: StaticData = StaticData { data: README };

static BOOT_SECTOR: [u8; 512] = [
    0x33u8, 0xed, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
    0x90, 0x33, 0xed, 0xfa, 0x8e, 0xd5, 0xbc, 0x00, 0x7c, 0xfb, 0xfc, 0x66, 0x31, 0xdb, 0x66, 0x31,
    0xc9, 0x66, 0x53, 0x66, 0x51, 0x06, 0x57, 0x8e, 0xdd, 0x8e, 0xc5, 0x52, 0xbe, 0x00, 0x7c, 0xbf,
    0x00, 0x06, 0xb9, 0x00, 0x01, 0xf3, 0xa5, 0xea, 0x4b, 0x06, 0x00, 0x00, 0x52, 0xb4, 0x41, 0xbb,
    0xaa, 0x55, 0x31, 0xc9, 0x30, 0xf6, 0xf9, 0xcd, 0x13, 0x72, 0x16, 0x81, 0xfb, 0x55, 0xaa, 0x75,
    0x10, 0x83, 0xe1, 0x01, 0x74, 0x0b, 0x66, 0xc7, 0x06, 0xf3, 0x06, 0xb4, 0x42, 0xeb, 0x15, 0xeb,
    0x02, 0x31, 0xc9, 0x5a, 0x51, 0xb4, 0x08, 0xcd, 0x13, 0x5b, 0x0f, 0xb6, 0xc6, 0x40, 0x50, 0x83,
    0xe1, 0x3f, 0x51, 0xf7, 0xe1, 0x53, 0x52, 0x50, 0xbb, 0x00, 0x7c, 0xb9, 0x04, 0x00, 0x66, 0xa1,
    0xb0, 0x07, 0xe8, 0x44, 0x00, 0x0f, 0x82, 0x80, 0x00, 0x66, 0x40, 0x80, 0xc7, 0x02, 0xe2, 0xf2,
    0x66, 0x81, 0x3e, 0x40, 0x7c, 0xfb, 0xc0, 0x78, 0x70, 0x75, 0x09, 0xfa, 0xbc, 0xec, 0x7b, 0xea,
    0x44, 0x7c, 0x00, 0x00, 0xe8, 0x83, 0x00, 0x69, 0x73, 0x6f, 0x6c, 0x69, 0x6e, 0x75, 0x78, 0x2e,
    0x62, 0x69, 0x6e, 0x20, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6e, 0x67, 0x20, 0x6f, 0x72, 0x20, 0x63,
    0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x2e, 0x0d, 0x0a, 0x66, 0x60, 0x66, 0x31, 0xd2, 0x66, 0x03,
    0x06, 0xf8, 0x7b, 0x66, 0x13, 0x16, 0xfc, 0x7b, 0x66, 0x52, 0x66, 0x50, 0x06, 0x53, 0x6a, 0x01,
    0x6a, 0x10, 0x89, 0xe6, 0x66, 0xf7, 0x36, 0xe8, 0x7b, 0xc0, 0xe4, 0x06, 0x88, 0xe1, 0x88, 0xc5,
    0x92, 0xf6, 0x36, 0xee, 0x7b, 0x88, 0xc6, 0x08, 0xe1, 0x41, 0xb8, 0x01, 0x02, 0x8a, 0x16, 0xf2,
    0x7b, 0xcd, 0x13, 0x8d, 0x64, 0x10, 0x66, 0x61, 0xc3, 0xe8, 0x1e, 0x00, 0x4f, 0x70, 0x65, 0x72,
    0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x73, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x20, 0x6c, 0x6f, 0x61,
    0x64, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2e, 0x0d, 0x0a, 0x5e, 0xac, 0xb4, 0x0e, 0x8a, 0x3e,
    0x62, 0x04, 0xb3, 0x07, 0xcd, 0x10, 0x3c, 0x0a, 0x75, 0xf1, 0xcd, 0x18, 0xf4, 0xeb, 0xfd, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0xa4, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xde, 0x00, 0x3d, 0x5f, 0x00, 0x00, 0x80,
    0x00, 0x01, 0x00, 0x00, 0x3f, 0xa0, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x13, 0x00, 0x00,
    0xfe, 0xff, 0xff, 0xef, 0xfe, 0xff, 0xff, 0xa4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55,
    0xaa,
];

unsafe extern "C" fn const_reader(dest: *mut u8, size: i32, offset: u32, userdata: usize) {
    let dptr = &*(userdata as *const StaticData);
    if offset as usize > dptr.data.len() {
        return;
    }
    let to_read = if offset as usize + size as usize > dptr.data.len() {
        dptr.data.len() - offset as usize
    } else {
        size as usize
    };

    core::ptr::copy_nonoverlapping(dptr.data.as_ptr().add(offset as usize), dest, to_read);
}

unsafe extern "C" fn null_read(_dest: *mut u8, _size: i32, _offset: u32, _userdata: usize) {}

impl EMfatStorage {
    pub fn new(disk_label: &str) -> EMfatStorage {
        let mut res = EMfatStorage {
            ctx: unsafe { core::mem::MaybeUninit::zeroed().assume_init() },
            fstable: EMfatStorage::build_files_table(),
        };
        emfat_rust::emfat_rust_init(&mut res.ctx, disk_label, res.fstable.as_mut_ptr());
        res
    }

    fn build_files_table() -> Vec<emfat_entry> {
        defmt::trace!("EmFat: Registring virtual files:");

        // TODO incapsulate constructing files
        let mut res = Vec::<emfat_entry>::new();

        defmt::trace!("EmFat: .. /");
        // /
        res.push(
            emfat_rust::EntryBuilder::new()
                .name("\0")
                .dir(true)
                .lvl(0)
                .offset(0)
                .size(0)
                .max_size(0)
                .build(),
        );

        defmt::trace!("EmFat: .. /Readme.txt");

        let ptr = &README_INFO as *const StaticData;
        res.push(
            emfat_rust::EntryBuilder::new()
                .name("Readme.txt\0")
                .dir(false)
                .lvl(1)
                .offset(0)
                .size(README.len())
                .max_size(README.len())
                .read_cb(const_reader)
                .user_data(ptr as usize)
                .build(),
        );

        defmt::trace!("EmFat: .. /Testfile.bin");
        res.push(
            emfat_rust::EntryBuilder::new()
                .name("Testfile.bin\0")
                .dir(false)
                .lvl(1)
                .offset(0)
                .size(1024 * 10)
                .max_size(1024 * 20)
                .read_cb(null_read)
                .build(),
        );

        defmt::trace!("EmFat: .. /fill.x");
        res.push(
            emfat_rust::EntryBuilder::new()
                .name("fill.x\0")
                .dir(false)
                .lvl(1)
                .offset(0)
                .size(65600 * 8 * 512)
                .max_size(65600 * 8 * 512)
                .read_cb(null_read)
                .build(),
        );

        res.push(emfat_rust::EntryBuilder::terminator_entry());

        res
    }
}

impl BlockDevice for EMfatStorage {
    const BLOCK_BYTES: usize = 512;

    fn read_block(&self, lba: u32, block: &mut [u8]) -> Result<(), BlockDeviceError> {
        defmt::trace!("SCSI: Read LBA block {}", lba);
        if lba > 0xfffffffe {
            unsafe {
                core::ptr::copy_nonoverlapping(BOOT_SECTOR.as_ptr(), block.as_mut_ptr(), 512);
            }
            /*
            unsafe {
                // костыль, либа дает константную ссылку, принудительно конвернируем
                // в неконстантный указатель
                let ctx = &self.ctx as *const emfat_t as *mut emfat_t;
                emfat_rust::emfat_read(ctx, block.as_mut_ptr(), lba, 1);
            }*/
        } else {
            for i in &mut block[0..512] {
                *i = 0
            }
        }
        Ok(())
    }

    fn write_block(&mut self, lba: u32, _block: &[u8]) -> Result<(), BlockDeviceError> {
        defmt::trace!("SCSI: Write LBA block {}", lba);
        /*
        unsafe {
            emfat_rust::emfat_write(&mut self.ctx, _block.as_ptr(), lba, 1)
        }
        */
        Ok(())
    }

    fn max_lba(&self) -> u32 {
        defmt::trace!("SCSI: Get max LBA {}", self.ctx.disk_sectors);
        self.ctx.disk_sectors - 1 // Это не размер а максимальный номер блока по 512 байт
    }
}
