/* automatically generated by rust-bindgen 0.59.1 */
const HEATSHRINK_AUTHOR: &'static [u8; 32usize] = b"Scott Vokes <vokes.s@gmail.com>\0";
const HEATSHRINK_URL: &'static [u8; 43usize] = b"https://github.com/atomicobject/heatshrink\0";
const HEATSHRINK_VERSION_MAJOR: u32 = 0;
const HEATSHRINK_VERSION_MINOR: u32 = 4;
const HEATSHRINK_VERSION_PATCH: u32 = 1;
const HEATSHRINK_MIN_WINDOW_BITS: u32 = 4;
const HEATSHRINK_MAX_WINDOW_BITS: u32 = 15;
const HEATSHRINK_MIN_LOOKAHEAD_BITS: u32 = 3;
const HEATSHRINK_LITERAL_MARKER: u32 = 1;
const HEATSHRINK_BACKREF_MARKER: u32 = 0;
const HEATSHRINK_STATIC_INPUT_BUFFER_SIZE: u32 = 32;
const HEATSHRINK_STATIC_WINDOW_BITS: u32 = 8;
const HEATSHRINK_STATIC_LOOKAHEAD_BITS: u32 = 4;
const HEATSHRINK_DEBUGGING_LOGS: u32 = 0;
const HEATSHRINK_USE_INDEX: u32 = 1;

type size_t = usize;

const HSE_sink_res_HSER_SINK_OK: HSE_sink_res = 0;
const HSE_sink_res_HSER_SINK_ERROR_NULL: HSE_sink_res = -1;
const HSE_sink_res_HSER_SINK_ERROR_MISUSE: HSE_sink_res = -2;
type HSE_sink_res = i32;
const HSE_poll_res_HSER_POLL_EMPTY: HSE_poll_res = 0;
const HSE_poll_res_HSER_POLL_MORE: HSE_poll_res = 1;
const HSE_poll_res_HSER_POLL_ERROR_NULL: HSE_poll_res = -1;
const HSE_poll_res_HSER_POLL_ERROR_MISUSE: HSE_poll_res = -2;
type HSE_poll_res = i32;
const HSE_finish_res_HSER_FINISH_DONE: HSE_finish_res = 0;
const HSE_finish_res_HSER_FINISH_MORE: HSE_finish_res = 1;
const HSE_finish_res_HSER_FINISH_ERROR_NULL: HSE_finish_res = -1;
type HSE_finish_res = i32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct hs_index {
    size: u16,
    index: [i16; 512usize],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct _heatshrink_encoder {
    input_size: u16,
    match_scan_index: u16,
    match_length: u16,
    match_pos: u16,
    outgoing_bits: u16,
    outgoing_bits_count: u8,
    flags: u8,
    state: u8,
    current_byte: u8,
    bit_index: u8,
    search_index: hs_index,
    buffer: [u8; 512usize],
}

extern "C" {
    fn heatshrink_encoder_reset(hse: *mut _heatshrink_encoder);
    fn heatshrink_encoder_sink(
        hse: *mut _heatshrink_encoder,
        in_buf: *mut u8,
        size: size_t,
        input_size: *mut size_t,
    ) -> HSE_sink_res;
    fn heatshrink_encoder_poll(
        hse: *mut _heatshrink_encoder,
        out_buf: *mut u8,
        out_buf_size: size_t,
        output_size: *mut size_t,
    ) -> HSE_poll_res;
    fn heatshrink_encoder_finish(hse: *mut _heatshrink_encoder) -> HSE_finish_res;
}
