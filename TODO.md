[v] Минимальная функциональность
    [v] Собирается
    [v] Запускается отладка
[v] Способ встраивания сторонних C-либ
    [v] Heatshrink
        [v] Сборка с остальной системой
        [v] Создать внешнюю либу, которая использует C под капотом
        [v] Собрать с либой, протестировать
[v] Начальная конфигурация клоков MCU
    [v] Найти правильную реализацию HAL
        tm32l4xx-hal, features = ["stm32l4x3", "rt"]
    [v] Разобраться как взаимодействовать с API
        use stm32l4xx_hal::stm32;

[v] "Перешагивать" код, где нет отладочных символов
    gdb: skip -rfu ^core::

[v] USB
    [v] Настрить минимальную сборку
    [v] Разобраться с получением stm32::Peripherals::take()
        unsafe {stm32::Peripherals::steal()}
    [v] Клокинг USB от PLLR (/2)
    [v] Виртуальный COM-порт работает

[x] Частота проца в конфиге FreeRTOS
    \- Переехали на RTIC \-

[v] Разобраться с cargo embed
    Смотри полную справку в обсидиане
    [v] Config: `.embed.toml`
    [v] Прошивка
    [v] Логирование: `rtt-target`
    [v] Отладка

[v] USB Mass Storage
    https://github.com/cs2dsb/stm32-usb.rs/tree/master/firmware/usbd_mass_storage
    [v] Выбрать VID/PID => 0x0483/0x5720
    [v] Пример запускается, но пока с заглушкой вместо чтения-записи
    [v] Удалось создать Mass Storage + ACM, но работает нестабильно
        [v] Под FreeRTOS бе части работают, но в винде только COM-порт ито как-то странно
        [v] Заставить работать в винде
    [v] Пример c Mass Storage жрет почти все мето в контроллере, почему?
        добавил оптимизацию 1 уровня - размер уменьшился в 2 раза `[profile.dev]/opt-level = 1`
    [x] Проверить распознает ли винда диск Mass Storage
        Не работает, вероятно проблема в "string descriptor 0 read error: -71"
    [x] RTIC Запуск задачи вне контекста прерывания
        Все задачи RTIC - это прерывания

[v] defmt : https://ferrous-systems.com/blog/defmt/
    Множественные изменение в настройках сборки

[v] Определить, оставляем RTIC или FreeRTOS 
    Выбрана FreeRTOS

[v] Привезти проект в порядок
    [v] Убрать варнинги от названий FreeRTOS
    [v] Вынести сервисный код в модули
    [v] Привезти в порядок хуки `defmt::panic!()`
    [v] Настроить зависимость от heatshrink-rust как подкаталог
    [v] Проверить конфиг FreeRTOS
        [v] configCPU_CLOCK_HZ <= from config
        [v] configUSE_MALLOC_FAILED_HOOK = 1
        [v] configUSE_TICKLESS_IDLE = 1 -> configUSE_LOBARO_TICKLESS_IDLE = 1
        [x] configPRIO_BITS - ?
    [v] Прерывания USB будит поток-обработчик
            use FreeRTOS wait-notify

[v] Определение режима работы в зависимости от того, включен ли USB
    [v] Определение, включен-ли USB
        [v] Мониторинг через pwr.sr2.PVMO1, делитель R2-R10 больше не нужен
        [v] Если не включен - не запускать драйвер
    [v] Различная настройка клоков для разных режимов
        Медленный режим - 12MHz (HSE => CPU) 
        Быстрый: (HSE = 12 / 3 40 / 2 => 80 => CPU), (HSE= 12 / 3 24 / 2 => PLLSAI1Q => USB)
        [v] Частоты установлены
        [x] Вместо rcc.cfgr.freeze использовать свою реализацию, посколькоу оно не даёт 
            возможности напрямую подать с HSE в CPU
        [v] Конвертор клоков, который пересчитвает милисекунды в тики в зависимости от частоты проца
    [v] FreeRTOS будет настроен на медленный режим (12MHz), в быстром тики будут идти чаще.
    [v] Трейт для режимов работы
        Поскольку полиморфизм очень странно себя ведет, то виртуальные функции юзать лучше не
        надо, генерики и компайл-тайм полиморфизм!

[v] Поток мониторинга
    [v] Краш при попытке malloc() - проверить объем памяти проца
        [v] Defmt не влияет
        [v] ломается цепочка блоков аллокатора
        [v] Прерывание USB не при чем
        [v] Запись идет в функции vTaskGetInfo() pxTaskStatus->uxBasePriority = 1; pxTaskStatus->ulRunTimeCounter = 0; pxTaskStatus указывает в неправильное место!
        [v] Проверить размеры структур
            Структура FreeRtosTaskStatusFfi Rust не соответствует структуре xTASK_STATUS С
            [x] Найти и переключиться на правильную версию FreeRTOS
            [v] Форкнута библиотека freertos-rust  пофикшено там, создан issue https://github.com/lobaro/FreeRTOS-rust/issues/15 
    [v] Отладить вычисление задержки на сон потока мониторинга
        [v] Спецфункция-врапер
    [v] Лог и неспящий FreeRTOS только в режиме debug
        [v] Раздельные конфигурации
        [v] Раздельные FreeRTOSConfig.h
        [v] vApplicationIdleHook только для отладочного режима
    [v] Тест Релиз-сборки
    [x] Мониторинг в отдельный канал RTT, сериализовать FreeRtosSchedulerState
        Есть спец-либа defmt\-rtt\-target, но она для defmt 0.1, одифицировать слишком сложно
    [v] Настроить линкер так, чтобы _SEGGER_RTT не прыгала
        Сложно. Будем вычислять на лету
        [v] Скрипт
    [v] cargo-make
        [v] Задачи - Makefile.toml
        [v] add to Readme
    [v] Статус FreeRtos - вывод за 1 команду, чтобы не было разделений.
        [x] Радобраться как печатается структура с вложенными полями.
        [v] Печать сборкой длинной строки в памяти

[v] Virtual fat
    [v] Сборка
        [v] strlen() missing
            Добавлена реализация на Rust
    [v] Чтение
    [x] Запись
        Недопилено в библотеке
    [v] Работает В Windows
        [v] SCSI: Rest ready - no answer
        [v] Форк библиотеки usbd_scsi
            [v] Встроить субмодулем
        [v] Команда 0x23 
            [v] Исправлен парсинг
            [v] Создан ответ
        [v] sdc: p1 size 82 extends beyond EOD, enabling native capacity
            https://wi-cat.ru/forums/topic/133/#postid-1602
            [v] Поле disk_sectors структуры stm32_usb_self_writer::threads::storage.ctx не является размером диска, нужно добавлять значение stm32_usb_self_writer::threads::storage.ctx.priv_.boot_lba
        [v] Решено: Смотри ZLP
    [v] BOS Descriptor: Response data (unknown descriptor type 15): 050f0c000107100200000000
        Согласно Universal Serial Bus 3.0 Specification, пункт 9.6.2.1:
            05 - длина заголовка дескриптора в байтах
            0f - BOS Descriptor
            0c00 - обзаяя длина всего десккриптора
            01 - 1 дескриптор в пакете:
                07 - размер этого дескриптора в байтах
                10 - тип дескриптора - "DEVICE COMPABILITY"
                02 - константа "Universal Serial Bus 3.0 Specification"
                00 00 00 00 - бит 1 == 0 - Universal Serial Bus 3.0 Specification не поддерживается
    [v] Device qualifier: Empty response
        [v] отсутсвует в либе, делается отлуп (reject)
            Дискриптор должен сообщить хосту как он хочет работать на большей скорости, а поскользу устройство не может - то и дескриптор не нужен:
            https://www.keil.com/pack/doc/mw/USB/html/_u_s_b__device__qualifier__descriptor.html
    [v] Endpoint descriptor: Interval == 0
        Значение только для изохорного и Interrupt ржимов: с каким периодом опрешивать конечную точку точку в единицах базового интервала USB. Игнорируется для остальных типов конечных точек
    [v] Почему кард-ридер получает запросы через USB ?.?.2, а ответ посылает через ?.?.1, тогда 
            как наше устройство все через ?.?.1 ?
            Ответ: Кард-ридер юзает точку 0x81 (IN) и 0x02 (OUT), а наш девайс 0x81 (IN) и 0x01 (OUT)
            [v] А так точно можно?
                Да можно, судя по таблице выделения памяти конечным точкам для каждой есть независимый
                Указатель USB_ADDRn_\[RT\]X и размер буфера USB_COUNTn_\[RT\]X
    [v] USB_COUNTn_RX - таблица
            Это делается в stm32_usbd::endpoint::set_out_buf()/set_in_buf()
    [v] Почему не работает с 8-битным доступом `EP_MEMORY_ACCESS_2X16 = false`? должно быть
            медленнее, но не ломаться совсем, нет? Не получается запросить даже дискриптор устройства.
            Неверно заполняется таблица указателей на буфера конечных точек: значения записываются как
            будто их адреса в 2 раза больше. На лицо неверная адресация. оставляем `EP_MEMORY_ACCESS_2X16 = true`
    [v] Для устройств Full Speed можно иметь размер конечных точек типа Bulk только 8, 16, 32 или 64
            байта, поэтому 256 и отваливается в ошибку -EOVERFLOW
    [v] Проверить, нет ли неопознанных команд
        [v] парсинг - Нет
        [v] Обработка - Нет
    [v] Обнаружено расхождение: в Windows не присылается пакет показывающий успех выполнения чтения
            Из-за этого драйвер не может определтить прошло-ли чтение
        [v] Определение проблемы - Вместо пакета подтвеждения присылается пакет ZLP 
                только при повторном запросе присылается верный пакет, Linux игнорирует проблему.
        [v] Закостылить.
            В библиотеку `lib/stm32-usb.rs/firmware/usbd_bulk_only_transport` обавлена фича, запрещающая
            отправку ZLP, фича прокидывается через библиотеку `lib/stm32-usb.rs/firmware/usbd_scsi`.
    [v] Привезти исходный код в порядок после тестов
        [v] Убрать лишние изменения из библиотеки stm32-usb.rs
        [v] Убрать лишние изменения из библиотеки emfat
        [v] Убрать отладочный код
    
[v] Composite device: Mass Storage + VCP
    [v] Разобраться, что происходит, если не создавать композит вообще
        LINUX: все работает
        Windows: Mass Storage работает, VCP - нет
        Если посмотреть на дискрипторы, то:
        ```
        # несущественные поля опущены
        CONFIGURATION DESCRIPTOR # шапка
            wTotalLength: 90 # общая длина в байтах
            bNumInterfaces: 3 # 3 интрфейса
        # это работает
        INTERFACE DESCRIPTOR (0.0): class Mass Storage
            bInterfaceNumber: 0 # номер интерфейса
        # использует 2 конечные точки на вход и выход
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x01  OUT  Endpoint:1
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x81  IN  Endpoint:1
        # тут не хватает Interface Association Descriptor
        # -- Это не работает --
        # Это интерфейс управления CDC Control
        INTERFACE DESCRIPTOR (1.0): class Communications and CDC Control
            bInterfaceNumber: 1 # номер интерфейса
        COMMUNICATIONS DESCRIPTOR #???
        COMMUNICATIONS DESCRIPTOR #???
        COMMUNICATIONS DESCRIPTOR #???
        COMMUNICATIONS DESCRIPTOR #???
        # 1 конечная точка управления CDC, одна от девайса к хосту, хост 
        # периодически читает её чтобы узнать состояние устройства, 
        # и далее что-то передает или читает из CDC-Data
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x82  IN  Endpoint:2
        # Это интерфейс данных CDC-Data
        INTERFACE DESCRIPTOR (2.0): class CDC-Data
            bInterfaceNumber: 2 # номер интерфейса
        # И его конечные точки
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x83  IN  Endpoint:3
        ENDPOINT DESCRIPTOR
            bEndpointAddress: 0x03  OUT  Endpoint:3
        ```
        Винда ругается, мол "Указано несуществующее устройство", по видимому не хватает,
        как раз Interface Association Descriptor перед class Communications and CDC Control
    [v] Изучить процесс отправки дескрипторов
        Оказывается, все в либе уже есть, нужно было лишь включить этоу возможность
        `UsbDeviceBuilder::composite_with_iads()` и в `UsbDevice<T>::poll(&mut[...])` 
        сувать список ранее созданных интерфейсов в порядке регистрации.
        После этого появляется заполненый Interface Association Descriptor в нужном месте.
    [v] Наростение периода неудачного пулинга *2
        [v] Прерывание происходит очень часто на самом деле, поэтому скалирование задержки не имеет смысла
            Сделаем навсегда до прерывания
            Сразу спала нагрузка на процессор потоком USB до <1%

[v] protobuf
    [v] Попытка поспользоваться nanopb
        [v] Генератор
            [v] Код генератора на питоне, необходимо тащить питоновские скрипты с собой
                Упакуем их в бинарь https://stackoverflow.com/a/47889785
            [x] Плагин генератора надо еще собирать - не нужно
            [v] Работает
            [v] Нативная либа собирается
    [v] ядро nanopb
        [v] Враперы API
    [v] поток обработки Protobuf
        [v] Дедлок: поток usbd пулит стек usb и получает информацию, что пришли данные на конечную току
            виртуального com-порта. pool() самого порта путой. Выходим из главного pool() с true
            а раз так то заходим в него еще раз и вновь имеем, что данные не забраны, опять результат true
            А поскольку usbd имеет максимальный приоритет, то он пулит вечно и не дает шанса обработчику
            все-таки забрать свои данные.
                Форкаем либу и добавляем чтение из конечной точки в кольцевой буфер через pool()
        [v] Наладить обработку сообщений
    [v] Заполнить протокол обмена
        [v] Настройки
            [v] Коэфициенты P-16 T-5
            [v] Неверное энкодирование массива f32 информация о поле не верна
                Добавлен метод кодирования поля, f32 кодируется как variant
            [v] Определение полного количества настраиваемых фич
                [v] Info
                    1. HW_Version/SW_Version - U32
                    2. Флаг несиправности каналов - bool[]
                    3. Флаги выхода за рабочий диопазон - bool[]
                    4. Флаги выхода за рабочий диопазон - bool[]
                    5. Флаг перегрева/передава/перегрева электроники - bool[]
                [v] Config
                    1. Serial - RW (U32)
                    2. Включение канала давления/температуры/измерения питания/температура процессора - bool[]
                    3. Рабочие диопазоны давлений/температур/питаний - f32
                    4. Коэфициенты - f32[]
                    5. Значение опорной частоты - U32
                    6. Пароль - строка\[10\]
                    7. Дата последней калибровки (ДДММГГГГ)
                    8. Коррерция 0 по температуре и давлению - RW (f32)
                    9. Конфигурация записи: {
                        BaseInterval - базовый такт записи, в мс
                        PWriteDevider - записывать давление каждые N BaseInterval-ов
                        TWriteDevider - записывать давление каждые M TWriteDevider-ов
                    }
                    10. Стартовая задержка записи после включения питания - (секунд) U32
                    11. Ед. изм. давления
                [v] Выходные значения
                    1. Измеренные давление и температура - f32
                    2. Температура электроники - f32
                    3. Нарпяжение на батарее - f32
                    4. "Сырые" отладочные значения (Target/result/ADC) - U32
                [v] Команды флеш
                    1. Размер стринцы памяти
                    2. Количество доступных страниц Flash для записи
                    3. Количество занятых страниц
                    4. Сброс флагов мониторинга перегрева/передава/перегрева
                    5. Очистка флешки
                [v] Установка пароля
                    1. Новый пароль
            [v] Реорганизация файла protobuf_server.rs
            [v] Код обработки сообщений
            [v] Обновить биндинги в соответствии новым протоколом
            [v] Обновить device_info::fill_info() в соответсвии с новым протоколом
            [v] Разрешение мониторинга перегрева/передава (критические значения != NAN)
    [v] Заполнить карту в KalibratorGUI
        [v] минимальное соединение работает
        [v] Заменить отправку стримом буферизированной отправкой, гую не очень нравится порезанное на 
            куски сообщение
        [v] Выход за рабочий диопазон/Критический перегрев-передав
        [v] Спец-соманды
            [v] Смена пароля
                [v] Окно
                [v] Обработчик
            [v] Очистка памяти
                [v] Окно
                [v] Обработчик
                [v] при очистке памяти сбрасывать кеш поиска свободной страницы
                [v] Стирание памяти
                    [v] В МК
                        [v] Имитация долгой работы delay'ем
                    [v] Во внешней флешке
            [v] Сброс мониторинга
                [v] Окно
                [v] Обработчик
        [v] Заполнить названия ячеек
        [v] Выходное значение Vbat в В.
    [v] Тестирование
    [v] Защищенные паролем значения
    [v] Передача файла опций плагину nanopb 
        Через `--nanopb_opt=--options-file=/path/to/file.option`
    [v] Перепривязать методы от I/OOStream на pb_i/ostream_s
    [v] Настройки
        [v] Хранилище
        [v] CRC
        [v] Интерфейс с protobuf
            [v] Чтение
            [v] Запись
            [v] Ошибки
                [v] ID устройства
                [v] Версия протокола
                [v] Ограничения на значения полей
            [v] Отладка
        [v] Псефдофайл, содержащий конфигурацию
            [v] Печатать не все настройки, скипать пароль, например
                `#[serde(skip_serializing)]`
        [v] Некоторые настройки не должны сохраняться
    [v] Замена nanopb на https://github.com/tokio-rs/prost
        [v] Добавлено к сборке
        [v] Процессинг заголовка
        [v] Парсинг тела сообщения
        [v] Пбработка тела
        [v] Построение ответа
        [v] Сериализация
        [v] Замена чтения и записи nanopb
        [v] Удаление nanopb

[v] Мониторинг состояния кучи
    [v] отключаемый через фичу
[x] Сериализация/Десериализация настроек при помощи protobuf
    Передумал, не тронь - и так работает
[v] log: секунды.милисекунды
[x] cargo::track()
    Не гуглится. Где я это видел?
[v] Псевдофайл, содержащий инфу о занятом месте
[v] Макрос, делающий null-terminated строки
[v] Менеджаер прерываний - обертка чтобы не зависеть от конкретного контроллера
[v] Экономия процессорного времени
    [v] Пробуждать поток protobuf только если usb.pool() == true
        Проблемы не было, просто в отстутвие работающих потоков ломался мониторинг defmt
        На отладку добавлен специальный псевдо-IDLE поток
    [v] Подбор переиода сна usbd
        Бесконечность
[v] Генерация конфига FreeRTOS
    [v] Поля, зависимые от билда
    [v] Шаблон
    [v] Генератор

[v] Частотомеры
    [x] Использовать готовый C-код из CAN
        Слишком много зависимостей, в том числе HAL
    [v] Частотмер на Rust
        Приоритет событий:
            1. Транзакция DMA
            2. Прерывание завершения транзакции DMA
            3. Прерывание перерполнения мастер-счетчика
        [v] Мастер-счетчик
            [v] Считает
            [v] TIMx_CR1:UIFREMAP 
                Судя по описанию, когда =1 битик TIMx_SR:UIF копируется в
                бит 31 TIMx_CR1:CNT и будет захвачен DMA. Если он будет 1 можно будет судить,
                что на момент захвата прерывание стриггерилось но еще не обработано, а следовательно
                экстендер содержит значение на 1 меньше чем правда!
            [x] Попробовать LPTIM аймер как опору
                Нет бита, аналогичного UIFREMAP
            [v] Маестер счетчик 32 бита (16+16), соответственно он должен преполняться с периодом 
                1/80кк 2^32 = 53,6 c
            [v] Снизить базовую частоту делителем APB1 (/8) (может меньше из-за USB)
            [v] Низкий приоритет прерывания мастер-счетчика
                ```
                Согласно моим рассуждениям, у прерывания мастер-счетчика должен быть низкий приоритет
                А у рабочих счетчиков выше, однако защитить инкриминт расширителя и сбро флага прерывания
                критической секцией. С другой стороны, при при обновлении захваченного значения
                Учинывать был ли бит UIFREMAP, и если был, и сейчас флаг прерывания мастер счетчика установлен
                то увеличить считать значение расширителя +1, иначе - нет.
                ```
                [v] Критичекая секция
                [v] Обновление обновлятора значения
            [v] Подключение Входных каналов
                [v] Пины питания генераторов
            [v] Начала и конец измерительного цыкла вместо циклической работы
                Старт: Счетчик остановлен, ставим значение Reload - 1,  TIMx_CR1.OPM = 0
                Таймер тосчитывает 1 импульс и сбрасывается -> DMA -> Старт захвачен -> Прерывание TIMx_CR1.OPM = 1
                Счетчик отсчитывает заданное количество входных импульсов
                Переполнение -> DMA -> Стоп захвачен -> аймер остановился автоматически
                [v] Изменить старт таким образом, чтобы он не реагировал на попытку запустить 
                    работающий счетчик
                [v] Старт убирает бит TIMx_CR1.OPM и TIMx_CR1.CNT =  TIMx_CR1.ARR - 1
                [v] В зависимости от состояния бита TIMx_CR1.OPM генерировать разное событие при вызове колбэка
                    после DMA
                [v] В состоянии Start установить бит TIMx_CR1.OPM
            [v] Проверить цыклический режим после обнаружения неисправности с захватом
                Тоже работает, надо решить какой режим использовать
                [x] Режим с остановкой более управляем, так как четко захвачено начало и конец,
                    а между ними можно *Четкосменить таргет
                [v] В поточном режиме меньше прерываний в 2 раза, но каждое следующее должно иметь достоверный
                    результат предыдущего, то есть после смены таргета нужно все равно начинать c TIMx_CR1.CNT =  TIMx_CR1.ARR - 1
            [v] Определить способ нахождения первого стартового результата
                Пусть этим занимается уже процессор результата, а не счетчик
                [v] Удалить остатки режима старт-стоп
                [v] Заменить метод start() на cold_start() который ставит TIMx_CR1.CNT =  TIMx_CR1.ARR - 1
                [v] Если set_target32() вызывается на работающем счетчика - паника!
    [x] Обнаружена иголка. Значение result: 19991648 -> 200316 = diff|19791332, затем адаптация воостановила.
        [v] Точно известно, что старший бит счетчика отразает действительно-ли счетчик был переполнен и прерывание
            не обработано. Ранее сделанная эвристика надежно не работает.
            [v] Костыль: перезапуск измерения если факт был обнаружен.
            [x] Проанализировать разницу результатов, если она близка к 0xffff +/- 500 (например) делать нужную поправку - ненадежно
    [v] Частота зависит от времени измерения?
        При малых временах измерения частота катастрофически занижается, это занижение тем меньше, чем больше время измерения.
        Обнаружено, что нужно к значению таргета добавлять +1 при вычислении частоты
        [v] Добавить компенсацию в as_target32()
        [?] Таргет давления не опускается ниже 99 при времени измерения < 100 мс
    [v] DMA
        [v] Конфигураци зависит от счетчика к которому подключается канал DMA
        [v] Настройка частотомера - есть расширение навешеное на счетчик, только подходящие
            счетчики имеют такое расширение, остальные не имплиментированы вообще
        [v] В терминах Rust HAL то что в таблице 41. даташита названо Channel это cXs, а то что названо
            CxS - это map
        [v] DMA захватывает значение мастер-счетчика
        [v] Организация вычисления полноценного значеий target и result
        [x] Бит TIMx_CR1.UIFCPY не захватывается DMA почему-то, в принципе он вроде и не нужен
                Получается, можно просто проверить если флаг прерывания мастер-счетчика установлен
                то добавим к расширителю +1.
        [v] Надоело туда-сюда вертеть режим, сделать старт-стоп фчичей
    [v] Процессор датчиков должен знать частоту работы опорного счетчика, а не "магическое число"
    [v] Неавтоматическая адаптация
        [v] Перенос подсчет частоты в FreqmeterController
        [v] Перенос вычисления частоты в impl RawValueProcessor
        [v] Добавить адаптацию
        [v] Процессинг значения возвращает новое значение для адаптации, или None, тогда используется старое
    [v] Обработка потери сиграла на входе
        [v] Таймер отсчитывающий 1,5 времени измерения канала
        [v] Если дошел до конца, посылает событие Timeout(ch)
        [v] В случае получения события ReadyFChannel(ср) сброс этого таймера
        [v] Если получено событие Timeout(ch), рестарт чатсотомера начальный таргет + гвард на время измерения 1.5
    [v] Вывод данных в protobuf
        [v] target / result
        [v] Частоты
        [v] Частотные выходные данныне
        [v] Аналоговые значения АЦП
        [v] Аналоговые величины
    [v] Промежуточные вычисления в double
        [v] Частота
        [v] Давление
        [v] Температура
        [v] Аналог
            [v] Версия 0.6.0 HAL'а не поддерживала ADC API пшлось брать из репозитория
                [v] Изменен механизм задания Пинов I/O и ADC (Если пин с альтернативной функцией, то он задается
                    как выход)
            [v] Все варианты разрешения АЦП кроме 12 бит бессмыслены, поскольку вычисление температуры
                требует на вход 12-битный результат.
        [v] Вывод конвертировать назад в float
    [v] Подготовка к режиму низкого энергопоребления
        Добавить политику, котоая отвечает за процессинг сырых значений в зависимости от режима.

[v] Режим высокой производительнсти
    [v] Обработка частотных каналов
        [v] Отладка
        [v] Запись события выхода за максимальный допустимый предел
            [v] Работает, только если критическое значение не NAN, фильтр мониторинга 
                всегда возвращает false, если лимит - NAN
    [v] Обработка аналоговых каналов
        [v] Напряжеине Vbat
        [v] Температура процессора
            [v] Период измерения температуры процессора = время измерения температуры
            [v] период измерения Vbat = min(время измерения температуры, время измерения давления)
    [v] Снизить базовую чстоту до 40 MHz
    [v] АЦП, почему оно рывками работает?
        [v] Похоже дело в частоте, снижение до 40 МHz все чинит, надо проверить прескейлер
            Добавлен предделитель от базовой частоты
    [v] Пересчет едениц измерения давления
    [v] Корректировка нуля по каналам
    [v] Чтение из Flash
        [v] Чтение из собственной памяти МК
        [v] Чтение из QUARD_SPI flash
    [v] Вычисление статистики занятого пространства
        [v] Поиск первого незанятого блока после указанного
        [v] Для режима датчика вычислить количество занятых страниц заранее, чтобы не повесить USB
            [v] Искать первую незанятую страницу в процессе инициализации, и закешировать результат
                Если новый поиск запросит искать начиная со страницы меньше, то просто вернуть ему 
                готовый результат

[_] Режим самописца
    [v] Периферия, требуемая для режима низкого энергопотребления
        [v] rcc
        [v] flash
        [v] pwr
        [v] clocks
        [v] interrupt_controller
        [v] crc
        [v] in_p
        [v] in_t
        [v] en_p
        [v] en_t
        [v] dma1_ch2
        [v] dma1_ch6
        [v] timer1
        [v] timer2
        [v] adc
        [v] adc_common
        [v] vbat_pin
        [v] Обновить клокинг конфиг
        [v] led pin
    [v] Архитектура
        [v] Предварительный "прогрев" генераторов заранее *2 времени измерения
        [v] Отключение генераторов при большой разнице между временем измерения и периодом записи
    [_] Запись
        [v] Подготовка данных
        [v] Сжатие страниц
        [v] Запись во внутреннюю FLASH MK
            [v] 2 страницы
            [v] 8 страниц
        [_] Запись в QUARD_SPI flash
            [v] Тестовая запись
            [v] Чтение и проверка
            [v] Проблемы с адресацией, похоже флешке высылается адрес = (ADDR - 0x90000000) >> 8
                Обрезается младшие 8 байт, нужна ли 32 битная адресация? или это как-то иначе решается.
                проблема оказалась в том, что в конфиге был 32-х битный адрес, а флешка настраивалась на 
                24-х битный.
            [_] Запись полной флешки
    [v] Адаптация
        [v] В случае перехода на новую страницу
        [v] В случае запуска после сна
        [v] Автоадаптация тебует по крайней мере 2 цыкла для получения правильного значения target
            Точность зависит от стартового количества импульсов, поэтому выбор между быстрой адаптацией
            И быстрым стартом
    [v] "Засыпание" в случае большого интервала записи
        [v] Алгоритм засыпания канала
        [v] Проверить, есть ли защита от установки делителя для канала в 0 и базового интервала в 0
            Допилено
        [v] Проверка снятия напряжения
            Fixed: Слишком ранне отключение каналов, прогрев не звершен.
        [v] Канал температуры показывет неадекватное значение - адаптация не проходит
            [v] Запускать канала в 2+ этапа, чтобы полцчить минимальную задержку после включения питания
            [v] Первые ~100ms канал температуры даёт частоту 100kHz, надо увеличить время начальной
                адаптации как минимум до 200мс
        [v] A АЦП выключается между шапками?
            Там было автоотключение после 1 измерения
        [v] Записать 2 страницы в таком режиме и проверить корректность
            [v] Есть иголки на канале температуры, неодинакового, но близкого размера? Генератор?
                Починено, см "Чиним иголки в режиме старт-стоп"
        [v] Убрать дебаг-псевдо-айдл, в пользу настоящего
            Непонятно почему, но сейчас оно просто работает без костылей
    [v] Добавить фактическое значение опорной чатоты в шапку блока данных
        [v] Библиотека
        [v] Запись
        [v] Декодер

[v] QuardSPI
    [v] https://russianblogs.com/article/5522908302/
    [v] В hal отсутвует поддержка QUARDSPI в чипе L433 по тому что нет регистров в зависимости stm32l4
        [v] Почему нет?
            В оригинальном .svd файле от ST для L4x3 нет секции об QSPI как она есть для L4x1 и L4x2
            Секция такая:
            ```xml
            <peripheral>
                <name>QUADSPI</name>
                <description>QuadSPI interface</description>
                <groupName>QUADSPI</groupName>
                <baseAddress>0xA0001000</baseAddress>
            ...
            </peripheral>
            ```
            Перед модулем `DBGMCU`
        [v] Проверить отладчиком существование чего-то по адресу 0xA0001000
            Читаются нули, нет ошибки доступа к памяти
    [v] Собственная реализация методом копи-пасты с необходимыми модицикациями
        [v] Перечислить все пины, доступные для QSPI
        [v] Заставить хотябы собираться
        [x] Убрать излишннюю копипасту, максимум импортов из оригинальных либ
            Все что тащится имеет приватные поля
        [v] Инициализация модуля
            Клок успешно подается
        [v] полностью передать владение аппаратным модулем QSPI соответствующем модулю кода, отключить зависимость
            от собственной флешки MK
            [x] Вместо передачи сконфигурированного модуля QSPI, передать "запчасти", ибо потом его надо будет
                перенастраивать на месте
            [v] Добавить в драйвер возможность "разобрать" его или переконфигурировать
                Qspi::apply_config()
        [v] Раздельное с мьютексом владение флешкой, поскольку в режиме USB нужно чтобы можно было стереть 
            флешку
        [v] Чтение JEDEC ID
        [v] Переключение в QuardSPI
            [v] Регистры
            [v] По идее флешка сразу должна переключиться в QSPI как только я задал конфиг однако она не 
                принимает изменения.
                [v] Изменять наcтройки контроллера QSPI следует сразу после того, как переключили флешку.
                [v] Разделить функцию конфигурации на 2 части - preapre и finalise_config
            [-] Туториал: драйвер QSPI флешки для openocd: https://visualgdb.com/tutorials/arm/stm32/flash/
            [v] Для записи в конфигурационный регистр есть примечание 8
                - The WRITE ENABLE command must be issued first before this operation can be executed.
            [v] Чтение JEDEC ID в режиме QUARD SPI
        [v] Конфигурирование флешки на чтение в режиме датчика
            - QSPI read memory mapped работает.
            [v] Чтение работает, но хост гугается на таймауты и в итоге флешку не монтирует.
                Починено, см. ниже. Аппаратная проблема.
        [v] Избавиться от копирования из выделенного региона в буфер, затем из буфера в USB
            [v] Изучить путь прохождения команды чтения
                - Scsi::process_command()
                - EMfatStorage::read_block()
                - emfat_read()
                - QSPIFlashPageAccessor::read_to()
            [v] Хак с перенаправлением буфера, магическая комбинация
                [v] Фича библиотеки usbd_scsi `direct-read-hack` -> `usbd_bulk_only_transport/direct-read-hack`
                [v] QSPIFlashPageAccessor::read_to() заменить на метод который запишет в предоставленый
                    буфер специальную стректуру, которая при однаружении перенаправит чтение в другое место
                    указанное в ней
                [v] Функция записи при обнаружении такой штуки должна читать не из буфера а из указанного места
            [x] Копирование в буфер конечной точки с использованием DMA
                С последними изменениями процессор хать и занят копированием 99% времени, но при этом отзывчив
                и выполняет остальные функции, свитаю дальнеёшую оптимизацию нецелесообразной, тем более, что запись
                в буфер USB хитрая.
        [v] Убрать регион памяти `WRITER_TEST_AREA`
        [v] Поднять приоритет процесса `Tmr Svc` до максимального
        [v] Добавить поддержку блокировки флшки со стороны девайса, путем ответа на запросы кодом 
            `Check Condition (0x02)`
            [v] Добавить проверку готовности в трейт BlockDevice
            [v] Добавить обработку в Scsi
            [v] Проверить, требуется ли она в ответе накоманду `Test unit ready (0x00)`
                Добавлено, работает.
            [v] Проверка, не идет-ли стирание
        [v] Изучение функции глубокого сна у флешки
            - Команда 0xB9: ENTER DEEP POWER DOWN
            - команда 0xAB: RELEASE FROM DEEP POWERDOWN
            [v] Добавить посыл команды выхода из слипа при создании QSPIFlashPageAccessor и входа в
                Слип при его унечтожении.
            [v] Аналогично нужно будет снять со слипа когда будет происходить стирание
            [v] Чтобы не дрочить флешку уход в слип по таймеру
    [v] Старт новой последовательности - сброс счетчика
        [v] CpuFlashDiffWriter::try_create_new_page() создает заголовок страницы где уже прописан номер
            Нужен начальный сброс 
            Номер вынесен как параметр, чтобы контроллер записи сам о нем заботился.
    [v] Проверка работы расширителя адреса
        Работает, проверено принудительной записью по начиная с адреса 0x1000000 
    [v] Светодиодик
        Только красный!
        [v] Работа с USB
        [v] Мигнуть при старте новой страницы
    [v] Запись: получение страницы и сон флешки
        [v] Поиск свододной страницы не делает сразу захват страницы, а росто возвращает номер
    [v] Декодер: для каждой последовательности своя папка, иначе все в кучу.

[v] Переход на отладку при помощи плагина cortex-debug, там есть дамп памяти и загрузка svd
    [v] [Дамп памяти](https://github.com/Microsoft/vscode-cpptools/issues/1503#issuecomment-767481312)
        ```
        1- Start a debug session.
        2- Open the command pallet (press F1).
        3- Type Cortex-Debug: View memory.
        4- Type in memory location (e.g. 0x08000000).
        5- Type in memory length (e.g. 128).
        ```
    [v] Пропатчить STM32L4x3.svd так, чтобы появился модуль QSPI в отладчике

[v] Обновить монитор так, чтобы он показывал мгновенную загрузку проца, а не статистику за все время
        
[B] Modbus сервер, как альтернатива Protobuf, не вместе!
    [x] Подбор библиотеки - Чет там все сложно, но ориентировочно https://github.com/zzeroo/libmodbus-rs
        Это для компа
    [_] Используем старый, провереный freemodbus
        [_] Фичи: либо modbus либо protobuf но не вместе, modbus по дефолту
        [_] Биндинг
        [_] Таймер
        [_] IO
        [_] CRC16 use HW CRC
        [_] KalibratorGUI
    
[v] Переставить компаратор на TLV3012 и попробовать на 1,8 В
[x] Стандартные Vid/Pid чтобы windows7 распознавала CDC/ACM
    [v] Запихать драйвер (.inf) прямо на виртуальный диск
    [v] Сделать одной функцией любые статические данныне, не только строки
[v] Утечка памяти при сохранении настроек - краш после пары раз
    [v] при отладке поток, который выполняе сохранение делает своеё дело и остается зомби по тому что его ресурсы
        должен подчистить IDLE который на когда не выполняется.
        [v] Перенести сохранение из специального потока в таймер
[v] При малых временах измерения в режиме USB переполнение очереди контроллера измерений
    Множество улучшений и компромиссов, включена фича freqmeter-start-stop по дефолту, с ней лучше работает при
    малых временах измерения. Устойчиво работает на времени измерения 20мс, кратковременный "лаг" при монтировании
    виртуального диска. Приоритет процесса USB приравнен к приоритету процессинга сенсоров
[v] Починить CRC32 тобы оно соответствовало zlib'овскому
    // https://stackoverflow.com/a/48883954
    config
        .input_bit_reversal(BitReversal::ByByte)
        .output_bit_reversal(true)
    Результат инвертировать!

[v] FreqmeterController::enable() Убрать задержку старта, она очень мешает нормальному процессингу.
[v] Пониженное энергопоребление
    [v] Полное отключение - standby
        [v] при заполнеии памяти
        [v] при падении напряжения батарейки ниже минимального питания из настроек
    [v] Обычный режим процессора - Low-power run
        [v] Есть толк
        [v] Снизить частоту процессора, переписсать cfgr.freeze() под конкретные задачи для обоих режимов
            0.5 мА с 1 генератором на привязи @ 3MHz
[v] Флаги критческого превышения параметров
    Режим самописца все это делает, посколку для шапки вычисляет все это а в вычислениях уже встроена проверка
[v] В релизе падает при инициализации режима датчика, невозможный тергет
    По какой-то причине результат мог быть равен 0, приравнимаем это к потере сигнала и обрабатываем
    сответсвенно
[v] Чиним иголки в режиме старт-стоп
    - Есть много иголок вниз (результат перебор) по обоим каналам - на 65528
    - Есть 1 иголка вверх (результат вниз на 655536)
    [v] Вернуть проверку разницы результатов 0xffff +/- 500
    [v] Тестирование
    [v] Тестирование записи
        [x] Частые потери сигнала на канале температуры (режим Тизм << Период записи)
            [x] Записать лог-анализаором и проверить
                Похоже на проблему генератора
        [v] На периоде равном времени записи - работает
        
[v] Изучить freertos_rust::patterns::compute_task
    A task that can terminate and return its return value.
    ```rust
    let task = Task::new().compute(|| {
     	CurrentTask::delay(Duration::ms(100));
     	42
    }).unwrap();
    let result = task.into_result(Duration::ms(1000)).unwrap();
    ```
    Не подходит для задач "запустил и забыл", а именно для задач запустил и когда-нибудь получишь результат.
    Проверять нельзя, так как либо задача завршилась, либо таймаут и паника.
    В той же папке есть реализация паттерна "подписка" с одним источником и многими подписчиками.
    
[v] Включение/выключение измерительных каналов: Выключение снимает питание, а включение не возвращает.
    [v] Нужно при включении посылать команду в командную очередь
        [v] протащить командную очередь в обработчик protobuf
    [v] Аналоговые каналы тоже включаются-выключаются

[v] Починить измерение Vbat
    Все в норме, просто учитывай что измеренть больше чем 1.8 * 2 = ~3.6 не удастся.
    Поменял верхний резистор делителя на 270к

[v] Обнаружен баг: С некоторой вероятностью блиотека SCSI может отправлять результат чтения хосту
    длиной меньше запрошенного. Замечен недостаток, кратный 128 байтам, возможно меньше.
    Сами данные корректные, только хвост не присылается.
    После 6-7 попыток хост сдается и ресетит USB в девайсе, это попогает на некоторое время.
    Данное поведение связано с размеров файловой системы emfat. Чем больше блоков занято и чем больше
    генерируется таблица, тем выше шанс нарваться на данный баг.
    Из всех попыток хоста всегда разный уровень потерь.
    Изучение времени доступа показало, что в хучшем случае само чтение занимет менее 100us, но этого
    уже достаточно чтобы все ломалось. 
    Процессор загружен высоко процессом USB, Снизил приоритет чтобы не ломалась измериловка.
        [v] Почему теряется хвост пакета?
            Обнаружено, что в impl BulkOnlyTransport::flush() словие `if self.data_i == self.buffer_i || residue == 0` срабатыват иногда по первому варианту, что далее в check_end_data_transfer()
            намекает ("STATE> Data residue > 0, early termination"), что у нас неожиданное навершение передачи. Это происходит первый раз на ответе на команду Mode Sence(6).
            [v] Проверить сколько реально байт записывается в буфер, почему ваершарк недоволен этим пакетом.
                Оказывается, что self.command_status_wrapper.data_residue - это сколько байт хост готов принять в ответ максимум. Это не ошибка, если девайс передает меньше.
            [v] Углубленная проверка показывает, что условие `if self.data_done && self.data_i == self.buffer_i`
                Срабатывает только на команду Mode Sence(6). Видимо драйвер считает, что все передал.
            - Ошибка может возникать совершенно спонтанно, несколько чтений норма - потом раз и сломалось.
            - Обнаружено, что процесс Protobuf должен быть менее приоритетным чем Usbd, иначе ломается.
            - Теория о том, что слишком много прерываний и переключений контекста была отброшена: если задать в конфиге FreeRTOS корректную частоту и тики будут раз в 1 мс - это ни чего не меняет.
            - Запрет автомонтирования флешек: https://access.redhat.com/solutions/20107
            - Драйвер всегда работает с 1 LBA=512 байт
                [v] проверить по WireShark во время затыка что показывает лог со стороны МК
                    Со стороны МК все пакеты считаются отправлеными.
            [v] Если убрать из колбэка чтения обрачени к emfat и заменить на заполнитель счетчиком?
                поведеине не меняется
            - Обнаружено, что после деффектных пакетов нет пакета `(Read(10)) (Good)`
            - Отключение спячки процесса USBd и дрочба в `poll()` не изменяет поведение
            - Включение ZLP ни как не влияет на поведение
            - bulk_only_transport.rs:238: Комент. Автор намекает что тоже получал странные неповторяющиеся ошибки.
            - Вычислено, что таймаут со стороны хоста составляет 30 сек. Дело точно не в нем.
            - Если заполнить блок нулями, то можно получить повторяемое поведение (забиваем все 0xff):
                1. Читается 1 блок LBA=0
                2. Читается 7 блоков начиная с LBA=1
                3. В ответ приходит только 1 блок + обязательная часть (шапка) 576 байт.
                4. Хост вновь повторяет команду и получает опять неполное количество байт и так 7 раз
                _Хост по воле левой пятки может вязть и зменить порядок. Особенно после перепрошивки_
            - обнаружена кратность меннее 512 байт. Видимо 64 байта - да, подтверждено. Прерывается ресетом
                устройства.
    [v] Диагностирована аппаратная проблема. 
        Намеком стал код ошибки у оборванных пакетов `-EPROTO` [Гугление](https://bugzilla.redhat.com/show_bug.cgi?id=125711) показало, что данная ошибка характерна для случаев отвала кабеля USB, но обычно она появляется при коннекте. А вот если инициализация успешно прошла и она вылетела потом то это очивка. Случай крайне редкий. В итоге залил прошивку в старую плату - а там работает!

[v] Fixes:
    [v] Не работает релизный билд
        Неверное выравнивание буфера в структуре struct BulkOnlyTransport приводило к крашу внутри C-кода.
    [v] Передача команды сна флешке не уменьшает поребление (7.7mA)
        Судя по описанию, в стендбае должно жрать мнеьше милиампера и еще в 2 раза меньше в дип слипе, но не 7мА
        Но S# должен быть 1 - есть
        - Заработал релизный билд - потребление 2,4мА с выключенными генераторами, 2,9 - с включенными.
        - Проц без флешки и генераторов поребляет 0,6мА во сне.
        - Проц в работе поребляет 1мА после включения лоу павер режима.
        - дерганье Reset флешки ни как не влияет на потребление.
        - Оказалось, что преобразователь 3.8 -> 1.8 жрет на ХХ 2мА
    [v] Скорость чения флешки в релизном билде на треть ниже чем в отладочном
        Подобраны параметры лелизного билда:
        - opt-level = "s"
        - lto = false 
        На потребление не повлияло.
    [v] Краш, если флешка отсутсвует
        Fixed
    [v] Релиз: Не работает датчик: нет питания на генераторах
        Небыло включения мастер-счетчика из-за того, что был выключен поток мониторинга, который включал
        его для своих нужд.

[v] Обнаружена остановка записи даже после передерга питания в печке.
    * Обнаружение последней непустой записи - работает
    * На столе работает
    * Если сломалось в печке, то на столе не пишет
    [v] Обнаружен Stack Overflow потока "RecCtrl" в релизном билде
        Добавлено 256 байт

[v] Переезд на новую версию Rust + CI/CD
    * [x] Обновить `prost` до последней версии

[ ] Отказ от FreeRtos и переезд на RTIC.
